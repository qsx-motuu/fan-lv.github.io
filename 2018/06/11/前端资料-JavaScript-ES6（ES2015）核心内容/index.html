<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ES6（ES2015）核心内容"><meta name="keywords" content="JavaScript,EcmaScript"><meta name="author" content="吕钒,15757856604@163.com"><meta name="copyright" content="lvfan"><title>ES6（ES2015）核心内容【吕钒的后花园】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"DDS7QLTFBR","apiKey":"4e05b9f66dc7fb2160aef36bd87ecc5a","indexName":"lvfan","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#30-分钟掌握-ES6-ES2015-核心内容（上）"><span class="toc-number">1.</span> <span class="toc-text">30 分钟掌握 ES6/ES2015 核心内容（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Babel"><span class="toc-number">1.1.</span> <span class="toc-text">Babel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最常用的-ES6-特性"><span class="toc-number">1.2.</span> <span class="toc-text">最常用的 ES6 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#let-const"><span class="toc-number">1.2.1.</span> <span class="toc-text">let, const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class-extends-super"><span class="toc-number">1.2.2.</span> <span class="toc-text">class, extends, super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arrow-function"><span class="toc-number">1.2.3.</span> <span class="toc-text">arrow function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#template-string"><span class="toc-number">1.2.4.</span> <span class="toc-text">template string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#destructuring"><span class="toc-number">1.2.5.</span> <span class="toc-text">destructuring</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#default-rest"><span class="toc-number">1.2.6.</span> <span class="toc-text">default, rest</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-分钟掌握-ES6-ES2015-核心内容（下）"><span class="toc-number">2.</span> <span class="toc-text">30 分钟掌握 ES6/ES2015 核心内容（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import-export"><span class="toc-number">2.1.</span> <span class="toc-text">import export</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#传统的写法"><span class="toc-number">2.1.1.</span> <span class="toc-text">传统的写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6-的写法"><span class="toc-number">2.1.2.</span> <span class="toc-text">ES6 的写法</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">吕钒</div><div class="author-info-description">心之所向 素履以往 生如逆旅 一苇以航</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/fan-lv" target="_blank">GitHub<i class="icon-dot bg-color0"></i></a><a class="links-button button-hover" href="mailto:15757856604@163.com" target="_blank">E-Mail<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="tencent://message/?uin=1019593584&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color3"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">44</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">24</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">13</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">吕钒的后花园</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">ES6（ES2015）核心内容</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2018-06-11 | 更新于 2019-02-13</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/前端资料/">前端资料</a><i class="fa fa-angle-right" style="margin: 0 8px;"></i><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/前端资料/JavaScript/">JavaScript</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JavaScript/">JavaScript</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/EcmaScript/">EcmaScript</a></div></div></div><div class="main-content"><h2 id="30-分钟掌握-ES6-ES2015-核心内容（上）"><a href="#30-分钟掌握-ES6-ES2015-核心内容（上）" class="headerlink" title="30 分钟掌握 ES6/ES2015 核心内容（上）"></a>30 分钟掌握 ES6/ES2015 核心内容（上）</h2><p>ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准。因为当前版本的 ES6 是在 2015 年发布的，所以又称 ECMAScript 2015。</p>
<p>也就是说，ES6 就是 ES2015。</p>
<p>虽然目前并不是所有浏览器都能兼容 ES6 全部特性，但越来越多的程序员在实际项目当中已经开始使用 ES6 了。所以就算你现在不打算使用 ES6，但为了看懂别人的你也该懂点 ES6 的语法了…</p>
<p>在我们正式讲解 ES6 语法之前，我们得先了解下 Babel。</p>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用 Babel，具体过程可直接在 Babel 官网查看：</p>
<h3 id="最常用的-ES6-特性"><a href="#最常用的-ES6-特性" class="headerlink" title="最常用的 ES6 特性"></a>最常用的 ES6 特性</h3><p>let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments</p>
<p>这些是 ES6 最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。</p>
<a id="more"></a>
<h4 id="let-const"><a href="#let-const" class="headerlink" title="let, const"></a>let, const</h4><p>这两个的用途与 var 类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。</p>
<p>首先来看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"zach"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"obama"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">//obama</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//obama</span></span><br></pre></td></tr></table></figure>
<p>使用 var 两次输出都是 obama，这是因为 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而 let 则实际上为 JavaScript 新增了块级作用域。用它所声明的变量，只在 let 命令所在的代码块内有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"zach"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"obama"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">//obama</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//zach</span></span><br></pre></td></tr></table></figure>
<p>另外一个 var 带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 i 是 var 声明的，在全局范围内都有效。所以每一次循环，新的 i 值都会覆盖旧值，导致最后输出的是最后一轮的 i 的值。而使用 let 则不会出现这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>再来看一个更常见的例子，了解下如果不用 ES6，而用闭包如何解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clickBoxs = <span class="built_in">document</span>.querySelectorAll(<span class="string">".clickBox"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; clickBoxs.length; i++) &#123;</span><br><span class="line">  clickBoxs[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们本来希望的是点击不同的 clickBox，显示不同的 i，但事实是无论我们点击哪个 clickBox，输出的都是 5。下面我们来看下，如何用闭包搞定它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratorFactory</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> onclick;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> clickBoxs = <span class="built_in">document</span>.querySelectorAll(<span class="string">".clickBox"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; clickBoxs.length; i++) &#123;</span><br><span class="line">  clickBoxs[i].onclick = iteratorFactory(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const 也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="built_in">Math</span>.PI;</span><br><span class="line">PI = <span class="number">23</span>; <span class="comment">//Module build failed: SyntaxError: /es6/app.js: "PI" is read-only</span></span><br></pre></td></tr></table></figure>
<p>当我们尝试去改变用 const 声明的常量时，浏览器就会报错。</p>
<p>const 有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用 const 来声明可以避免未来不小心重命名而导致出现 bug：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> monent = <span class="built_in">require</span>(<span class="string">"moment"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="class-extends-super"><a href="#class-extends-super" class="headerlink" title="class, extends, super"></a>class, extends, super</h4><p>这三个特性涉及了 ES5 中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？</p>
<p>有了 ES6 我们不再烦恼！</p>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念。新的 class 写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"animal"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  says(say) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.type + <span class="string">" says "</span> + say);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.says(<span class="string">"hello"</span>); <span class="comment">//animal says hello</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"cat"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.says(<span class="string">"hello"</span>); <span class="comment">//cat says hello</span></span><br></pre></td></tr></table></figure>
<p>上面代码首先用 class 定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。简单地说，constructor 内定义的方法和属性是实例对象自己的，而 constructor 外定义的方法和属性则是所有实例对象可以共享的。</p>
<p>Class 之间可以通过<strong>extends</strong>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个 Cat 类，该类通过 extends 关键字，继承了 Animal 类的所有属性和方法。</p>
<p><strong>super</strong>关键字，它指代父类的实例（即父类的 this 对象）。子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。</p>
<p>ES6 的继承机制，实质是先创造父类的实例对象 this（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p>
<blockquote>
<p>P.S 如果你写 react 的话，就会发现以上三个东西在最新版 React 中出现得很多。创建的每个 component 都是一个继承 React.Component 的类。详见 react 文档</p>
</blockquote>
<h4 id="arrow-function"><a href="#arrow-function" class="headerlink" title="arrow function"></a>arrow function</h4><p>这个恐怕是 ES6 最最常用的一个新特性了，用它来写 function 比原来的写法要简洁清晰很多:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">//ES5</span></span><br><span class="line">(i) =&gt; i + <span class="number">1</span><span class="comment">//ES6</span></span><br></pre></td></tr></table></figure>
<p>简直是简单的不像话对吧…</p>
<p>如果方程比较复杂，则需要用{}把代码包起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  x++;</span><br><span class="line">  y--;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">(x, y) =&gt; &#123;</span><br><span class="line">  x++;</span><br><span class="line">  y--;</span><br><span class="line">  <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了看上去更简洁以外，arrow function 还有一项超级无敌的功能！</p>
<p>长期以来，JavaScript 语言的 this 对象一直是一个令人头痛的问题，在对象方法中使用 this，必须非常小心。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"animal"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  says(say) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.type + <span class="string">" says "</span> + say);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.says(<span class="string">"hi"</span>); <span class="comment">//undefined says hi</span></span><br></pre></td></tr></table></figure>
<p>运行上面的代码会报错，这是因为 setTimeout 中的 this 指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种：</p>
<ol>
<li><p>第一种是将 this 传给 self,再用 self 来指代 this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">says(say)&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self.type + <span class="string">' says '</span> + say)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种方法是用 bind(this),即</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">says(say)&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.type + <span class="string">' says '</span> + say)</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但现在我们有了箭头函数，就不需要这么麻烦了：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"animal"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  says(say) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.type + <span class="string">" says "</span> + say);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.says(<span class="string">"hi"</span>); <span class="comment">//animal says hi</span></span><br></pre></td></tr></table></figure>
<p> 当我们使用箭头函数时，函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。<br> 并不是因为箭头函数内部有绑定 this 的机制，实际原因是<strong><em>箭头函数根本没有自己的 this，它的 this 是继承外面的</em></strong>，因此内部的 this 就是外层代码块的 this。</p>
</li>
</ol>
<h4 id="template-string"><a href="#template-string" class="headerlink" title="template string"></a>template string</h4><p>这个东西也是非常有用，当我们要插入大段的 html 内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如 mustache 等等。</p>
<p>大家可以先看下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#result"</span>).append(</span><br><span class="line">  <span class="string">"There are "</span> +</span><br><span class="line">    basket.count +</span><br><span class="line">    <span class="string">" "</span> +</span><br><span class="line">    <span class="string">"items in your basket, "</span> +</span><br><span class="line">    <span class="string">""</span> +</span><br><span class="line">    basket.onSale +</span><br><span class="line">    <span class="string">" are on sale!"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们要用一堆的’+’号来连接文本与变量，而使用 ES6 的新特性模板字符串<code></code>后，我们可以直接这么来写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#result"</span>).append(</span><br><span class="line">  <span class="string">`There are <span class="subst">$&#123;basket.count&#125;</span> items   in your basket, <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">    basket.onSale</span></span></span><br><span class="line"><span class="string"><span class="subst">  &#125;</span>  are on sale!`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>用反引号（\）来标识起始，用 ${} 来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！</p>
<blockquote>
<p>React Router 从第 1.0.3 版开始也使用 ES6 语法了，比如这个例子：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">taco</span>/$&#123;<span class="attr">taco.name</span>&#125;`&#125;&gt;</span>&#123;taco.name&#125;Link&gt;</span><br><span class="line"></span><br><span class="line">React Router</span><br></pre></td></tr></table></figure>
<h4 id="destructuring"><a href="#destructuring" class="headerlink" title="destructuring"></a>destructuring</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">"ken"</span>;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="string">"lili"</span>;</span><br><span class="line"><span class="keyword">let</span> zoo = &#123; <span class="attr">cat</span>: cat, <span class="attr">dog</span>: dog &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(zoo); <span class="comment">//Object &#123;cat:"ken", dog:"lili"&#125;</span></span><br></pre></td></tr></table></figure>
<p>用 ES6 完全可以像下面这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">"ken"</span>;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="string">"lili"</span>;</span><br><span class="line"><span class="keyword">let</span> zoo = &#123; cat, dog &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(zoo); <span class="comment">//Object &#123;cat:"ken", dog:"lili"&#125;</span></span><br></pre></td></tr></table></figure>
<p>反过来可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = &#123; <span class="attr">type</span>: <span class="string">"animal"</span>, <span class="attr">many</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; type, many &#125; = dog;</span><br><span class="line"><span class="built_in">console</span>.log(type, many); <span class="comment">//animal 2</span></span><br></pre></td></tr></table></figure>
<h4 id="default-rest"><a href="#default-rest" class="headerlink" title="default, rest"></a>default, rest</h4><p>default 很简单，意思就是默认值。大家可以看下面的例子，调用 animal()方法时忘了传参数，传统的做法就是加上这一句 type = type || ‘cat’ 来指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  type = type || <span class="string">"cat"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(type);</span><br><span class="line">&#125;</span><br><span class="line">animal();</span><br></pre></td></tr></table></figure>
<p>如果用 ES6 我们而已直接这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params">type = <span class="string">"cat"</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(type);</span><br><span class="line">&#125;</span><br><span class="line">animal();</span><br></pre></td></tr></table></figure>
<p>最后一个 rest 语法也很简单，直接看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animals</span>(<span class="params">...types</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(types);</span><br><span class="line">&#125;</span><br><span class="line">animals(<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"fish"</span>); <span class="comment">//["cat", "dog", "fish"]</span></span><br></pre></td></tr></table></figure>
<p>而如果不用 ES6 的话，我们则得使用 ES5 的 arguments。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是 ES6 最常用的一些语法，可以说这 20%的语法，在 ES6 的日常使用中占了 80%…</p>
<h2 id="30-分钟掌握-ES6-ES2015-核心内容（下）"><a href="#30-分钟掌握-ES6-ES2015-核心内容（下）" class="headerlink" title="30 分钟掌握 ES6/ES2015 核心内容（下）"></a>30 分钟掌握 ES6/ES2015 核心内容（下）</h2><h3 id="import-export"><a href="#import-export" class="headerlink" title="import export"></a>import export</h3><p>这两个家伙对应的就是 es6 自己的 module 功能。</p>
<p>我们之前写的 Javascript 一直都没有模块化的体系，无法将一个庞大的 js 工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。</p>
<p>这有可能导致两个问题：</p>
<ol>
<li>一方面 js 代码变得很臃肿，难以维护</li>
<li>另一方面我们常常得很注意每个 script 标签在 html 中的位置，因为它们通常有依赖关系，顺序错了可能就会出 bug<br> 在 es6 之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种 CommonJS(服务器端)和 AMD（浏览器端，如 require.js）。</li>
</ol>
<p>如果想了解更多 AMD，尤其是 require.js，可以参看这个教程：why modules on the web are useful and the mechanisms that can be used on the web today to enable them</p>
<p>而现在我们有了 es6 的 module 功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。</p>
<p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</p>
<p>上面的设计思想看不懂也没关系，咱先学会怎么用，等以后用多了、熟练了再去研究它背后的设计思想也不迟！好，那我们就上代码…</p>
<h4 id="传统的写法"><a href="#传统的写法" class="headerlink" title="传统的写法"></a>传统的写法</h4><p>首先我们回顾下 require.js 的写法。假设我们有两个 js 文件: index.js 和 content.js,现在我们想要在 index.js 中使用 content.js 返回的结果，我们要怎么做呢？</p>
<p>首先定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//content.js</span></span><br><span class="line">define(<span class="string">"content.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"A cat"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后 require：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"./content.js"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(animal); <span class="comment">//A cat</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那 CommonJS 是怎么写的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">var</span> animal = <span class="built_in">require</span>(<span class="string">"./content.js"</span>); <span class="comment">//content.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">"A cat"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="ES6-的写法"><a href="#ES6-的写法" class="headerlink" title="ES6 的写法"></a>ES6 的写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> animal <span class="keyword">from</span> <span class="string">"./content"</span>; <span class="comment">//content.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">"A cat"</span>;</span><br></pre></td></tr></table></figure>
<p>以上我把三者都列出来了，妈妈再也不用担心我写混淆了…</p>
<p>ES6 module 的其他高级用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//content.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">"A cat"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> type = <span class="string">"dog"</span>;</span><br></pre></td></tr></table></figure>
<p>上面可以看出，export 命令除了输出变量，还可以输出函数，甚至是类（react 的模块基本都是输出类）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; say, type &#125; <span class="keyword">from</span> <span class="string">"./content"</span>;</span><br><span class="line"><span class="keyword">let</span> says = say();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`The <span class="subst">$&#123;type&#125;</span> says <span class="subst">$&#123;says&#125;</span>`</span>); <span class="comment">//The dog says Hello</span></span><br></pre></td></tr></table></figure>
<p>这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。</p>
<p>如果还希望输入 content.js 中输出的默认值(default), 可以写在大括号外面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> animal, &#123; say, type &#125; <span class="keyword">from</span> <span class="string">"./content"</span>;</span><br><span class="line"><span class="keyword">let</span> says = say();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`The <span class="subst">$&#123;type&#125;</span> says <span class="subst">$&#123;says&#125;</span> to <span class="subst">$&#123;animal&#125;</span>`</span>); <span class="comment">//The dog says Hello to A cat</span></span><br></pre></td></tr></table></figure>
<p>修改变量名</p>
<p>此时我们不喜欢 type 这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在 es6 中可以用 as 实现一键换名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> animal, &#123; say, type <span class="keyword">as</span> animalType &#125; <span class="keyword">from</span> <span class="string">"./content"</span>;</span><br><span class="line"><span class="keyword">let</span> says = say();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`The <span class="subst">$&#123;animalType&#125;</span> says <span class="subst">$&#123;says&#125;</span> to <span class="subst">$&#123;animal&#125;</span>`</span>); <span class="comment">//The dog says Hello to A cat</span></span><br></pre></td></tr></table></figure>
<p>模块的整体加载</p>
<p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> animal, * <span class="keyword">as</span> content <span class="keyword">from</span> <span class="string">"./content"</span>;</span><br><span class="line"><span class="keyword">let</span> says = content.say();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`The <span class="subst">$&#123;content.type&#125;</span> says <span class="subst">$&#123;says&#125;</span> to <span class="subst">$&#123;animal&#125;</span>`</span>); <span class="comment">//The dog says Hello to A cat</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常星号*结合 as 一起使用比较合适。</p>
</blockquote>
<p>终极秘籍</p>
<p>考虑下面的场景：上面的 content.js 一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到 type 这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; type &#125; <span class="keyword">from</span> <span class="string">"./content"</span>;</span><br></pre></td></tr></table></figure>
<p>由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。</p>
<p>ES6 帮我们实现了！</p>
<p>不过，目前无论是 webpack 还是 browserify 都还不支持这一功能…</p>
<p>如果你现在就想实现这一功能的话，可以尝试使用 rollup.js</p>
<p>他们把这个功能叫做 Tree-shaking，哈哈哈，意思就是打包前让整个文档树抖一抖，把那些并未被依赖或使用的东西统统抖落下去。。。</p>
<p>看看他们官方的解释吧：</p>
<blockquote>
<p>Normally if you require a module, you import the whole thing. ES2015 lets you just import the bits you need, without mucking around with custom builds. It’s a revolution in how we use libraries in JavaScript, and it’s happening right now.</p>
</blockquote>
<blockquote>
<p>注：转发自<a href="https://segmentfault.com/a/1190000004365693?share_user=1030000013416310" target="_blank">https://segmentfault.com/a/1190000004365693?share_user=1030000013416310</a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:15757856604@163.com">吕钒</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://www.lvfan.xyz/2018/06/11/前端资料-JavaScript-ES6（ES2015）核心内容/">https://www.lvfan.xyz/2018/06/11/前端资料-JavaScript-ES6（ES2015）核心内容/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.lvfan.xyz">吕钒的后花园</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2018/06/11/前端资料-综合总结-HTML、CSS、Javascript/"><i class="fas fa-angle-left">&nbsp;</i><span>HTML、CSS、JavaScript</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2018/06/11/前端资料-Vue-Vue使用中碰到的问题记录/"><span>Vue使用中碰到的问题记录</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2019 By 吕钒</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>